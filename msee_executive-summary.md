\newpage

# TLDR; nee Executive Summary

The pace, scale and speed of change in the software world has created nightmare for IT shops and engineering functions within small and large organizations alike.  Dependency complexity combined with the turnover of new technologies is escalating the need for greater software supply chain awareness and control.  Software engineering enterprises, organizations who design and develop software solutions for internal or external consumer use, are faced with the need for modern practices and tools - before they succumb to overwhelming technical debt and security vulnerabilities.

It takes a combination of culture, agile and dynamic processes, and evolving organization-wide services and tools for modern enterprises to manage proactively the aforementioned challenges.  The engineering culture must include analysts, developers, administrators, and operators who are continuously in control of the supply chain, performance and security requirements, and changes in available technologies.  More importantly, a workforce that is happily willing to work together without barriers during the lifespan of software systems.  The enterprise must engender a sense of leadership with well-defined processes that continuously evolve to enable pragmatic practices and methods - while providing auditable control.  The enterprise must adopt a "right tool for the job" approach, and enlist and grow the skills required to use those tools.  Monitoring and measurement of all of the software must be a hard requirement, and integral in the design, implementation and maintenance of the system.  Infrastructure and resources must be uniformly available for architects, developers, testers and operators to collaborate towards an efficient delivery apparatus that includes both production, development and test environments.

The focus of this paper is to give a brief overview of what it means to be and prepare for the modern software enterprise.  Here's the short list, unordered:

1. Development environments that replicate production (based on captured requirements that drive or derive from production systems), allowing for continuous delivery (possibly deployment)

2. Automate the functional (performance, security, etc.) testing environment, based on dynamically provisioned resources

3. Centrally manage ingress and produced artifacts in a controlled repository for all development languages and frameworks (Java, Python, Ruby, etc.)

4. Establish an open and sharing culture for developers with a social-coding platform (internal or externally managed) like Github

5. Adopt a "right tool for the job" mentality - allowing projects the flexibility to go through the decision-making process for down-selection of dependencies and tools.

6. Investigate deeply, the architectural infrastructure that best suits the long-term development and maintenance of all software projects (e.g. microservices, versus monolithic applications)

7. Provide suites of tools consistently to all projects (enterprise-managed issue/task tracking, source code management, testing infrastructure, self-service virtual machines, etc.) to allow for continuity and developer confidence

8. Remove walls between functional/operational staff, bringing the right skills to the projects early - specifically developers, operators, security and qa, and business analyst early and continuously through the lifecycle

9. Design infrastructure and software for measurement and metrics-based management up-front - providing operators with the tools required to automate the feedback loop

10. Support rewrites or termination of legacy products and services when the technical debt associated with them weighs more than the replacement effort.
